@using ContosoCrafts.WebSite.Models
@using ContosoCrafts.WebSite.Services
@inject JsonFileFlashcardService FlashcardService
@inject JsonFileCategoryService CategoryService
@inject LocalStorageFlashcardService FlashcardStorage
@* do not delete Microsoft.AspNeCore.Components.Web, handles navigation*@
@using Microsoft.AspNetCore.Components.Web
@inject NavigationManager MyNavigationManager



<div class="controls">

    <div class="control-item">
        <label class="select-label" for="categoryFilter">Filter by Category</label>
        <select class="select-category" id="categoryFilter" @onchange="HandleCategoryFilterChange">
            <option value="" selected="@(string.IsNullOrEmpty(selectedCategory))">
                All Categories
            </option>
            @foreach (var category in CategoryService.GetAllData())
            {
                <option value="@category.Id" selected="@(category.Id == selectedCategory)">
                    @category.Id
                </option>
            }
        </select>
    </div>

    <div class="control-item">
        <!-- Sorting Criteria -->
        <label class="select-label" for="sortCriteria">Sort By</label>
        <select class="select-category" id="sortCriteria" @onchange="HandleSortCriteriaChange">
            <option value="@SortOption.NoSorting">Without sorting</option>
            <option value="@SortOption.DifficultyEasyToHard">Easy to Hard</option>
            <option value="@SortOption.DifficultyHardToEasy">Hard to Easy</option>
            <option value="@SortOption.OpenCountMostToLeast">Most Flipped</option>
            <option value="@SortOption.OpenCountLeastToMost">Less Flipped</option>
            <option value="@SortOption.LastOpenedNewestFirst">Newest First</option>
            <option value="@SortOption.LastOpenedOldestFirst">Oldest First</option>
        </select>
    </div>
</div>

<div>
   <div class="masonry-grid">
        @if (HasNoFlashcards())
        {
            <p>No flashcards found with selected Category</p>
        }
        @foreach (var flashcard in GetFilteredAndSortedFlashcards())
        {
            bool isFlipped = IsFlipped(flashcard.Id);
            string flipClass = isFlipped ? "flipped" : "";

            <div class="card @flipClass" data-id="@flashcard.Id" @onclick="() => HandleClickOnCard(flashcard.Id)">
                <div class="card-header category">
                    <div>
                        <span class="category-item" style="background-color: @GetCategoryColor(flashcard.CategoryId)">
                            @flashcard.CategoryId
                        </span>
                    </div>
                    <div class="difficulty-group">
                        <span class="text-second">Level: </span>
                        @for (int i = 0; i < flashcard.DifficultyLevel; i++)
                        {
                            <img src="icons/dog-paw.svg" alt="dog-paw" class="difficulty-image"/>
                        }
                    </div>
                </div>

                <div class="card-body flashcard-body">
                    <p class="card-text text-center">
                        @if (isFlipped)
                        {
                            <span class="text-answer">@flashcard.Answer </span>
                        }

                        @if (!isFlipped)
                        {
                            <span class="text-question">@flashcard.Question</span>
                        }
                    </p>
                </div>

                <div class="card-footer flashcard-footer">
                    @if (ShouldDisplayFlippedLabel(isFlipped, flashcard.OpenCount))
                    {
                        <div class="flipped-counter">
                            <span>Flipped</span>
                            <span class="badge rounded-pill custom-badge ms-auto">@flashcard.OpenCount</span>
                        </div>
                        <div class="last-opened">
                            <span> @GetLastOpenedDate(flashcard.Id) </span>
                        </div>
                    }

                    @if (CanShowMoreInfoLink(isFlipped, flashcard.Url))
                    {
                        <a href="@flashcard.Url" target="_blank">More info</a>
                    }
                    @if (isFlipped)
                    {
                        <button class="btn btn-info btn-sm flashcard-button" @onclick="() => RedirectToUpdatePage(flashcard.Id)">
                            Update
                        </button>
                    }
                </div>
            </div>
        }
    </div>
</div>


@code {

    public enum SortOption
    {
        NoSorting,
        DifficultyHardToEasy, // Difficulty: Hard to Easy
        DifficultyEasyToHard, // Difficulty: Easy to Hard
        OpenCountMostToLeast, // Open Count: Most to Least
        OpenCountLeastToMost, // Open Count: Least to Most
        LastOpenedNewestFirst, // Last Opened Dates: Newest First
        LastOpenedOldestFirst // Last Opened Dates: Oldest First
    }

    // Selected flashcard
    FlashcardModel selectedFlashcard;

    // Dictionary to store the last opened dates of flashcards by their IDs
    public Dictionary<string, DateTime?> LastOpenedDates { get; private set; } = new();

    // No sorting by default
    private SortOption selectedSortCriteria = SortOption.NoSorting; 
    
    // No filtering by default
    public string selectedCategory = ""; 
   
    // Id of the selected card to manage state
    public string selectedCardId;

    // Track whether answer side is displayed
    public bool showAnswer;

    // Category Id obtained from URL to filter cards
    public string categoryId;

    // Flag to ensure data is loaded only once
    private bool _isDataLoaded = false;

    // Called after component has been rendered.
    // Ensures data is loaded on first render
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadFlashcardDataFromLocalStorage();
            StateHasChanged();
        }
    }

    // Loads flashcard metadata (last opened dates) from local storage
    public async Task LoadFlashcardDataFromLocalStorage()
    {
        // Fetch data from LocalStorageFlashcardService
        var flashcardData = await FlashcardStorage.GetAllAsync();

        // Populate the LastOpenedDates dictionary
        LastOpenedDates = flashcardData.ToDictionary(f => f.CardId, f => (DateTime?)f.LastOpenedDate);

        // Mark data as loaded
        _isDataLoaded = true;
    }

    // Gets the last opened date of a flashcard as a formatted string.
    public string GetLastOpenedDate(string cardId)
    {
        if (LastOpenedDates.ContainsKey(cardId))
        {
            // last opened date
            var date = LastOpenedDates[cardId];
            if (date.HasValue)
            {
                return "Opened: " + date.Value.ToLocalTime().ToString("g");
            }
        }

        return "";
    }

    // Fetches and filters flashcards based on the selected category ID
    public IEnumerable<FlashcardModel> GetFilteredFlashcards()
    {
        // Retrieves all flashcards from FlashcardService
        var allFlashcards = FlashcardService.GetAllData();

        if (!string.IsNullOrEmpty(categoryId))
        {
            return allFlashcards.Where(f =>
                string.Equals(f.CategoryId, categoryId, StringComparison.OrdinalIgnoreCase));
        }

        return allFlashcards;
    }


    public IEnumerable<FlashcardModel> SortFlashcards(IEnumerable<FlashcardModel> flashcards, SortOption sortCriteria)
    {
        return sortCriteria switch
        {
            // Ascending (Easy → Hard), Descending (Hard → Easy)
            SortOption.NoSorting => flashcards,
            SortOption.DifficultyEasyToHard => flashcards.OrderBy(f => f.DifficultyLevel), 
            SortOption.DifficultyHardToEasy => flashcards.OrderByDescending(f => f.DifficultyLevel), 

            // Ascending (Low → High), Descending (High → Low)
            SortOption.OpenCountLeastToMost => flashcards.OrderBy(f => f.OpenCount), 
            SortOption.OpenCountMostToLeast => flashcards.OrderByDescending(f => f.OpenCount), 


            // Ascending (from oldest to newest), Descending (New → Old)
            // DateTime.MaxValue places unopened cards at the end in ascending order.
            // DateTime.MaxValue places unopened cards at the beginning in descending order.
            SortOption.LastOpenedNewestFirst => flashcards.OrderByDescending(f =>
                LastOpenedDates.ContainsKey(f.Id) ? LastOpenedDates[f.Id] : DateTime.MaxValue), 
            SortOption.LastOpenedOldestFirst =>
                flashcards.OrderBy(f =>
                    LastOpenedDates.ContainsKey(f.Id) ? LastOpenedDates[f.Id] : DateTime.MaxValue) 
        };
    }

    public IEnumerable<FlashcardModel> GetFilteredAndSortedFlashcards()
    {
        // First, filter flashcards by category (if any category is selected)
        var filteredFlashcards = FlashcardService.GetFilteredFlashcardsByCategory(selectedCategory);

        // Then, sort flashcards by the selected criteria and direction
        return SortFlashcards(filteredFlashcards, selectedSortCriteria);
    }

    private void HandleSortCriteriaChange(ChangeEventArgs e)
    {
        selectedSortCriteria = Enum.Parse<SortOption>(e.Value.ToString());
        StateHasChanged(); // Triggers a re-render of the UI
    }

  private void HandleCategoryFilterChange(ChangeEventArgs e)
    {
        selectedCategory = e.Value.ToString();
        MyNavigationManager.NavigateTo("/Flashcards/" + selectedCategory, replace: true);
        StateHasChanged();
    }



    // Get color of the category
    public string GetCategoryColor(string topicId)
    {
        // Calls CategoryService to get color value for given topic ID
        var categoryColor = CategoryService.GetCategoryColorById(topicId);

        // Returns retrieved color value
        return categoryColor;
    }

    // Called whenever parameters of the component change, such as a new URL
    // This method extracts the category ID from the URL path
    protected override void OnParametersSet()
    {
        // Retrieves current URL path
        var urlPath = MyNavigationManager.ToBaseRelativePath(MyNavigationManager.Uri);

        // Extracts last segment of URL path if there are multiple segments,
        // otherwise, it assigns null if there is only one segment
        categoryId = urlPath.Split('/').Length > 1 ? urlPath.Split('/').Last() : null;
        selectedCategory = categoryId;
    }

    // Redirect to Update if Update button clicked on the card
    public void RedirectToUpdatePage(string cardId)
    {
        MyNavigationManager.NavigateTo("/FlashcardAdmin/Update/" + cardId, true);
    }

    // Toggles the selected flashcard between the question and answer side
    public void ToggleCard(string cardId)
    {
        // Check if the user is flipping to show answer
        var shouldFlipToAnswer = selectedCardId != cardId || !showAnswer;

        // Toggle the display of answer
        showAnswer = selectedCardId == cardId ? !showAnswer : true;
        selectedCardId = cardId;

        // Find the selected flashcard
        var flashcard = GetFilteredFlashcards().FirstOrDefault(f => f.Id == cardId);

        // Check if flashcard exists
        if (flashcard == null)
        {
            return;
        }

        // Check if the user is flipping to show the answer
        if (shouldFlipToAnswer)
        {
            // Increment OpenCount and update the flashcard data
            flashcard.OpenCount++;
            FlashcardService.UpdateFlashcard(flashcard);
        }
    }

    // Handles a click event on a card by updating its last opened date
    // and toggling the display
    public async Task HandleClickOnCard(string cardId)
    {
        await FlashcardStorage.UpdateAsync(cardId);
        LastOpenedDates[cardId] = DateTime.UtcNow;
        ToggleCard(cardId);
    }

    // Checks if there are no flashcards in filtered set
    public bool HasNoFlashcards() => !GetFilteredFlashcards().Any();

    // Determines if a specific card is currently flipped to answer side
    public bool IsFlipped(string cardId) => selectedCardId == cardId && showAnswer;

    // Checks if the "Flipped" label should be displayed based on whether  card is flipped and OpenCount
    public bool ShouldDisplayFlippedLabel(bool isFlipped, int openCount) => isFlipped == false && openCount > 0;

    // Checks if a "More info" link should be displayed when answer side is shown, URL is provided
    public bool CanShowMoreInfoLink(bool isFlipped, string url) => isFlipped && !string.IsNullOrEmpty(url);
}